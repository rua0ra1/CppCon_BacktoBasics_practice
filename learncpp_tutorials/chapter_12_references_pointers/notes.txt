12.1 introduction to compound data types
- Fortunately, C++ supports a second set of data types called compound data types. Compound data types are data types that can be constructed from fundamental 
  data types.
- the type of this function is void(int,double). Note that this type is composed of fundamental types, making it a compound type. of course, functions also have their own special 
behaviours as well (being callable)

12.2 Value categories (lvalues and rvalues)
- we defined an expression as “a combination of literals, variables, operators, and function calls that can be executed to produce a singular value”.
- Besides producing values and side effects, expressions can do one more thing: they can evaluate to objects or functions. We’ll explore this point further in just a moment.
- The type of an expression is equivalent to the type of the value, object, or function that results from the evaluated expression
- Note that the type of an expression must be determine at compile time (otherwise type checking and type deduction wouldn't work)
- The value category of an expression indicates whether an expression resolves to a value, a function, or an object of some kind
- prior to c++ 11 lvlaue and rvalue, after C++11 gvalue, prvalue, xvalues to support the move semantics
- lvalue and rvalue expressions
  1) an value is an expression that evaluates to an identifiable object or function (or bit field)
  2) An entity that has an identity can be differentiated from other similar entitites (typically by comparing the address of the entity)
  3) Entites with identities can be accessed via an identifier, reference, or pointer, and typically have  a lifetime longer than a single expression or statement
  4) since the introduction of constants into the language, lvalue come in two subtypes: a modifiable lvalue and non modifiable lvalue
  5) Rvalue is an expressiont hat is not lvalue. Rvalue expressions evalutate to a value.
  6) rvalues literals ( except c style string which are lvalue ), because style are strings are evulated to const char *. no move semantics apply for arrays
  7) rvalues return value of functions and operators that return by Value
- Lvalue expressions evaluate to an identifiable object.Rvalue expressions evaluate to a value.
- A full list of lvalue and rvalue expressions can be found here. In C++11, rvalues are broken into two subtypes: prvalues and xvalues, 
  so the rvalues we’re talking about here are the sum of both of those categories.
- A C-style string literal is an lvalue because C-style strings (which are C-style arrays) decay to a pointer. 
  The decay process only works if the array is an lvalue (and thus has an address that can be stored in the pointer). C++ inherited this for backwards compatibility
- The answer is that lvalue expressions will implicitly convert to rvalue expressions in contexts where an rvalue is expected but an lvalue is provided.
- A rule of thumb to identify lvalue and rvalue expressions:
  1) Lvalue expressions are those that evaluate to functions or identifiable objects (including variables) that persist beyond the end of the expression.
  2) Rvalue expressions are those that evaluate to values, including literals and temporary objects that do not persist beyond the end of the expression.

12.3 Lvalue references
- A reference is an alias for an exisitng object. once a reference has been defined, any operation ont he reference is applied to the object being referenced.
- A reference is essentially identical to the object being referenced.
- we can also create references to functions, though this is done less often
- c++ two type of references lvalue reference and rvalue references
- A lvalue reference just called a reference since prior to c++11 there was only one type of reference acts as an alias of an existing Lvalue
- When defining a reference, place the ampersand next to the type (not the reference variable’s name).
- For those of you already familiar with pointers, the ampersand in this context does not mean “address of”, it means “lvalue reference to”.
- Reference intitializaiton 
- When a reference is initialized with an object (or function), we say it is bound to that object (or function). 
  The process by which such a reference is bound is called reference binding. The object (or function) being referenced is sometimes called the referent.
- Lvalue references must be bound to a modifiable lvalue.
- References can’t be reseated (changed to refer to another object)
- Reference and refernt have idependent lifetimes
  1) A reference can be destroyed before the object it is referencing
  2) the object being referenced can be destroyed before the reference
- When ref dies, variable x carries on as normal, blissfully unaware that a reference to it has been destroyed.
- When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists. 
  Such a reference is called a dangling reference. Accessing a dangling reference leads to undefined behavior.

12.4 Lvalue references to const
- We discussed how an lvalue reference can only bind to a modifiable lvalue. 
- This is disallowed because it would allow us to modify a const variable (x) through the non-const reference (ref).
- By using the const keyword when declaring an lvalue reference, we tell an lvalue reference to treat the object it is referencing as const. 
 Such a reference is called an lvalue reference to a const value (sometimes called a reference to const or a const reference).
- Favor lvalue references to const over lvalue references to non-const unless you need to modify the object being referenced. *******************
- When this happens, a temporary object is created and initialized with the rvalue, and the reference to const is bound to that temporary object.
- If you try to bind a const lvalue reference to a value of a different type, 
  the compiler will create a temporary object of the same type as the reference, initialize it using the value, and then bind the reference to the temporary.
- Const references bound to temporary objects extend the lifetime of the temporary object
- Lvalue references can only bind to modifiable lvalues.
- Lvalue references to const can bind to modifiable lvalues, non-modifiable lvalues, and rvalues. This makes them a much more flexible type of reference.
- 













